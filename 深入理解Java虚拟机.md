
### Java运行时数据区域：
1.程序计数器：一块较小的内存空间，可以看作是当前线程所执行的字节码的行号指示器。多线程时，为了线程切换后能恢复到正确的位置，每条线程都必须有一个独立的程序计数器，各个线程之间计数器互不影响，独立存储，即“**线程私有**”。<br>
2.Java虚拟机栈：也是“**线程私有**”的，生命周期与线程相同，它描述的是Java方法执行的内存模型：每个方法在执行时会创建一个**栈帧**(Stack Frame)，用于存储**局部变量表、操作数栈、动态链接、方法出口**等信息。局部变量表中存放了编译期可知的各种数据类型：基本类型(boolean,byte,short,int,float,long,double)，对象引用(reference类型，可能是指向一个对象起始地址的引用指针，也可能是指向一个对象代表的句柄)和returnAddress类型(指向了一条字节码指令的地址)。其中64位的double和long类型会占据两个局部变量表空间(Slot)，其余的数据类型只占据一个。局部变量表所需的内存空间大小在编译期间完成分配，在方法运行期间不会改变其大小。在Java虚拟机规范中，对这个区域规定了两种异常情况：如果线程请求的栈深度大于虚拟机栈所允许的深度(如递归)，则会报出**StackOverflowError**;如果虚拟机栈动态扩展时申请不到足够的内存，则会报**OutOfMemoryError**;<br>
3.本地方法栈：本地方法栈与虚拟机栈的作用类似，区别就是虚拟机栈为虚拟机执行Java方法服务，而本地方法栈为虚拟机执行Native方法服务。<br>
4.Java堆：**被所有线程共享的一块区域**，在虚拟机启动时创建。此内存区域的唯一目的就是**存放对象实例，几乎所有的对象实例都在这里分配内存**。Java堆是垃圾收集器管理的主要区域，由于现在收集器都采用分代收集算法，所以Java堆可以细分为**新生代和老年代**，再细致一点可以分为**Eden空间，From Survivor空间和 To Survivor空间**。<br>
5.方法区：也是**被所有线程共享的一块区域**，用于存放加载的类信息、常量、静态变量、即时编译后的代码等。<br>
6.运行时常量池：是方法区的一部分。Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池(Constant Pool Table)，用于存放编译期生成的字面量和符号引用。运行时常量池相对于Class文件常量池的另外一个重要特征是**动态性**，Java语言并不要求常量只有在编译期才能产生，运行期间也可以将新的常量放入常量池中，**例如String.inter()方法**。
### 垃圾收集器与内存分配策略
1.**引用计数算法**(Reference Counting)：给对象中添加一个引用计数器，每当有一个地方引用他时，计数器值就加1；当引用失效时，计数器值就减1；任何时刻计数器值为0的对象就是不可再被使用的。**优势：实现简单、判定效率高** **劣势:很难解决对象之间互相循环引用的问题**
2.**可达性分析算法(Reachability Analysis)** ：从"GC ROOTS"对象开始向下搜索，搜索所走过的路径称为引用链(Reference Chain)，当一个对象到GC ROOTS没有任何引用链连接时，则证明此对象不可用。**可被称为GC ROOTS的对象：1.虚拟机栈(栈帧中本地变量表)引用的对象 2.方法区中类静态属性引用的对象 3.方法区中常量引用的对象 4.本地方法栈JNI中引用的对象**
### 对象生存还是死亡？
即使在可达性分析算法中不可达的对象，也并非是“非死不可”的：**如果对象在进行可达性分析后没有与GC ROOTS相连的引用链，那它将会被第一次标记并进行一次筛选，筛选的条件是此对象是否有必要执行finalize()方法，当对象没有覆盖finalize()方法和此方法已被虚拟机调用过，都被视为“没有必要执行”。如果此对象有必要执行finalize()方法，这个对象会被放进F-QUEUE队列中，并在稍后由一个虚拟机自动建立的、低优先级的Finalizer线程去执行。finalize()方法是对象逃离死亡的最后一次机会--对象在此方法中与引用链重新链接上即可。如果这时他还没有逃脱，那他基本上真的被回收了。**<br>

